"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("dotenv/config");
const path_1 = require("path");
const os_1 = require("os");
const fs_1 = require("fs");
const server_1 = require("@storybook/core/server");
const utils_1 = require("../utils");
const devkit_1 = require("@nrwl/devkit");
function storybookExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* storybookExecutor_1() {
        let frameworkPath = utils_1.getStorybookFrameworkPath(options.uiFramework);
        const frameworkOptions = (yield tslib_1.__await(Promise.resolve().then(() => require(frameworkPath)))).default;
        const option = storybookOptionMapper(options, frameworkOptions, context);
        // print warnings
        runStorybookSetupCheck(options, context);
        yield tslib_1.__await(runInstance(option));
        yield yield tslib_1.__await({ success: true });
        // This Promise intentionally never resolves, leaving the process running
        yield tslib_1.__await(new Promise(() => { }));
    });
}
exports.default = storybookExecutor;
function runInstance(options) {
    var _a;
    const env = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : 'development';
    process.env.NODE_ENV = env;
    return server_1.buildDevStandalone(Object.assign(Object.assign({}, options), { ci: true, configType: env.toUpperCase() })).catch((error) => {
        var _a;
        // TODO(juri): find a better cleaner way to handle these. Taken from:
        // https://github.com/storybookjs/storybook/blob/dea23e5e9a3e7f5bb25cb6520d3011cc710796c8/lib/core-server/src/build-dev.ts#L138-L166
        if (error instanceof Error) {
            if (error.error) {
                devkit_1.logger.error(error.error);
            }
            else if (error.stats &&
                error.stats.compilation.errors) {
                error.stats.compilation.errors.forEach((e) => devkit_1.logger.log(e));
            }
            else {
                devkit_1.logger.error(error);
            }
        }
        else if ((_a = error.compilation) === null || _a === void 0 ? void 0 : _a.errors) {
            error.compilation.errors.forEach((e) => devkit_1.logger.log(e));
        }
        devkit_1.logger.log('');
        devkit_1.logger.warn(error.close
            ? `
          FATAL broken build!, will close the process,
          Fix the error below and restart storybook.
        `
            : `
          Broken build, fix the error above.
          You may need to refresh the browser.
        `);
        process.exit(1);
    });
}
function storybookOptionMapper(builderOptions, frameworkOptions, context) {
    utils_1.setStorybookAppProject(context, builderOptions.projectBuildConfig);
    const storybookConfig = findOrCreateConfig(builderOptions.config, context);
    const optionsWithFramework = Object.assign(Object.assign(Object.assign(Object.assign({}, builderOptions), { mode: 'dev', configDir: storybookConfig }), frameworkOptions), { frameworkPresets: [...(frameworkOptions.frameworkPresets || [])] });
    optionsWithFramework.config;
    return optionsWithFramework;
}
function findOrCreateConfig(config, context) {
    const sourceRoot = context.workspace.projects[context.projectName].root;
    if (config.configFolder && fs_1.statSync(config.configFolder).isDirectory()) {
        return config.configFolder;
    }
    else if (fs_1.statSync(config.configPath).isFile() &&
        fs_1.statSync(config.pluginPath).isFile() &&
        fs_1.statSync(config.srcRoot).isFile()) {
        return createStorybookConfig(config.configPath, config.pluginPath, config.srcRoot);
    }
    else if (fs_1.statSync(path_1.join(context.root, sourceRoot, '.storybook')).isDirectory()) {
        return path_1.join(context.root, sourceRoot, '.storybook');
    }
    throw new Error('No configuration settings');
}
function createStorybookConfig(configPath, pluginPath, srcRoot) {
    const tmpDir = os_1.tmpdir();
    const tmpFolder = `${tmpDir}${path_1.sep}`;
    fs_1.mkdtempSync(tmpFolder);
    fs_1.copyFileSync(configPath, `${tmpFolder}/${path_1.basename(configPath)}`, fs_1.constants.COPYFILE_EXCL);
    fs_1.copyFileSync(pluginPath, `${tmpFolder}/${path_1.basename(pluginPath)}`, fs_1.constants.COPYFILE_EXCL);
    fs_1.copyFileSync(srcRoot, `${tmpFolder}/${path_1.basename(srcRoot)}`, fs_1.constants.COPYFILE_EXCL);
    return tmpFolder;
}
function runStorybookSetupCheck(options, context) {
    let placesToCheck = [
        {
            path: devkit_1.joinPathFragments('.storybook', 'webpack.config.js'),
            result: false,
        },
        {
            path: devkit_1.joinPathFragments(options.config.configFolder, 'webpack.config.js'),
            result: false,
        },
    ];
    placesToCheck = placesToCheck
        .map((entry) => {
        return Object.assign(Object.assign({}, entry), { result: fs_1.existsSync(entry.path) });
    })
        .filter((x) => x.result === true);
    if (placesToCheck.length > 0) {
        devkit_1.logger.warn(`
  You have a webpack.config.js files in your Storybook configuration:
  ${placesToCheck.map((x) => `- "${x.path}"`).join('\n  ')}

  Consider switching to the "webpackFinal" property declared in "main.js" instead.
  ${options.uiFramework === '@storybook/react'
            ? 'https://nx.dev/latest/react/storybook/migrate-webpack-final'
            : 'https://nx.dev/latest/angular/storybook/migrate-webpack-final'}
    `);
    }
}
//# sourceMappingURL=storybook.impl.js.map