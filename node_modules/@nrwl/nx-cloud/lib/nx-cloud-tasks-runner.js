"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const from_1 = require("rxjs/internal/observable/from");
const switchMap_1 = require("rxjs/internal/operators/switchMap");
const tasks_runner_v2_1 = require("@nrwl/workspace/src/tasks-runner/tasks-runner-v2");
const output_1 = require("@nrwl/workspace/src/utilities/output");
const environment_1 = require("./utilities/environment");
const axios_1 = require("./utilities/axios");
const cloud_enabled_runner_1 = require("./core/runners/cloud-enabled/cloud-enabled.runner");
const nxCloudTasksRunner = (tasks, options, context) => {
    if (!environment_1.ACCESS_TOKEN && !options.accessToken) {
        return tasks_runner_v2_1.tasksRunnerV2(tasks, options, context);
    }
    if (environment_1.INVOKED_BY_RUNNER) {
        return tasks_runner_v2_1.tasksRunnerV2(tasks, options, context);
    }
    if (environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnAgent(tasks, options);
    }
    // distributed execution main job
    if (process.env.NX_CLOUD_DISTRIBUTED_EXECUTION === 'true' &&
        !environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnMainJob(tasks, options);
        return from_1.from(verifyNxCloudWorkspaceEnabled(options)).pipe(switchMap_1.switchMap((res) => {
            if (res.data.enabled) {
                return require('./core/runners/distributed-execution/distributed-execution.runner').nxCloudDistributedTasksRunner(tasks, options, context);
            }
            output_1.output.warn({
                title: 'Nx Cloud: Workspace Disabled',
                bodyLines: [
                    'This run and following runs will not use distributed task execution until',
                    'the outstanding balance is paid or additional coupons are added for this',
                    'workspace. If you believe you are receiving this message in error, please',
                    'contact support at cloud-support@nrwl.io.',
                    '',
                    'Execution will now continue using this machine only.',
                ],
            });
            return cloud_enabled_runner_1.cloudEnabledTasksRunner(tasks, options, context);
        }));
    }
    return cloud_enabled_runner_1.cloudEnabledTasksRunner(tasks, options, context);
};
function verifyNxCloudWorkspaceEnabled(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const axiosInstance = axios_1.createApiAxiosInstance(options);
        return yield axios_1.axiosMultipleTries(() => axiosInstance.get('/nx-cloud/executions/workspace-status'), 30);
    });
}
function verifyAllOperationsAreCacheableOnMainJob(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    tasks.forEach((task) => {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output_1.output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target ${task.target.project}:${task.target.target} cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can invoke this command without distribution by doing "NX_CLOUD_DISTRIBUTED_EXECUTION=false nx ...".`,
                ],
            });
            process.exit(1);
        }
    });
}
function verifyAllOperationsAreCacheableOnAgent(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    tasks.forEach((task) => {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output_1.output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target ${task.target.project}:${task.target.target} cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can still invoke "nx ${task.target.target} ${task.target.project}" from within a cacheable target when using "@nrwl/workspace:run-commands".`,
                ],
            });
            process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
        }
    });
}
exports.default = nxCloudTasksRunner;
//# sourceMappingURL=nx-cloud-tasks-runner.js.map