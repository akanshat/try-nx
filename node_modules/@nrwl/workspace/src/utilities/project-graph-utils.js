"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectNameFromDirPath = exports.getSourceDirOfDependentProjects = exports.projectHasTargetAndConfiguration = exports.projectHasTarget = void 0;
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const project_graph_1 = require("../core/project-graph");
function projectHasTarget(project, target) {
    return project.data && project.data.targets && project.data.targets[target];
}
exports.projectHasTarget = projectHasTarget;
function projectHasTargetAndConfiguration(project, target, configuration) {
    return (projectHasTarget(project, target) &&
        project.data.targets[target].configurations &&
        project.data.targets[target].configurations[configuration]);
}
exports.projectHasTargetAndConfiguration = projectHasTargetAndConfiguration;
function getSourceDirOfDependentProjects(projectName, projectGraph = project_graph_1.readCachedProjectGraph('4.0')) {
    if (!projectGraph.nodes[projectName]) {
        throw new Error(`Couldn't find project "${projectName}" in this Nx workspace`);
    }
    const nodeNames = findAllProjectNodeDependencies(projectName, projectGraph);
    return nodeNames.map((nodeName) => projectGraph.nodes[nodeName].data.sourceRoot);
}
exports.getSourceDirOfDependentProjects = getSourceDirOfDependentProjects;
/**
 * Finds the project node name by a file that lives within it's src root
 * @param projRelativeDirPath directory path relative to the workspace root
 * @param projectGraph
 */
function getProjectNameFromDirPath(projRelativeDirPath, projectGraph = project_graph_1.readCachedProjectGraph('4.0')) {
    let parentNodeName = null;
    for (const [nodeName, node] of Object.entries(projectGraph.nodes)) {
        const normalizedRootPath = devkit_1.normalizePath(node.data.root);
        const normalizedProjRelPath = devkit_1.normalizePath(projRelativeDirPath);
        const relativePath = path_1.relative(normalizedRootPath, normalizedProjRelPath);
        const isMatch = relativePath && !relativePath.startsWith('..');
        if (isMatch || normalizedRootPath === normalizedProjRelPath) {
            parentNodeName = nodeName;
            break;
        }
    }
    if (!parentNodeName) {
        throw new Error(`Could not find any project containing the file "${projRelativeDirPath}" among it's project files`);
    }
    return parentNodeName;
}
exports.getProjectNameFromDirPath = getProjectNameFromDirPath;
/**
 * Find all internal project dependencies.
 * All the external (npm) dependencies will be filtered out
 * @param {string} parentNodeName
 * @param {ProjectGraph} projectGraph
 * @returns {string[]}
 */
function findAllProjectNodeDependencies(parentNodeName, projectGraph = project_graph_1.readCachedProjectGraph('4.0')) {
    const dependencyNodeNames = new Set();
    collectDependentProjectNodesNames(projectGraph, dependencyNodeNames, parentNodeName);
    return Array.from(dependencyNodeNames);
}
// Recursively get all the dependencies of the node
function collectDependentProjectNodesNames(nxDeps, dependencyNodeNames, parentNodeName) {
    const dependencies = nxDeps.dependencies[parentNodeName];
    if (!dependencies) {
        // no dependencies for the given node, so silently return,
        // as we probably wouldn't want to throw here
        return;
    }
    for (const dependency of dependencies) {
        const dependencyName = dependency.target;
        // we're only intersted in project dependencies, not npm
        if (dependencyName.startsWith('npm:')) {
            continue;
        }
        dependencyNodeNames.add(dependencyName);
        // Get the dependencies of the dependencies
        collectDependentProjectNodesNames(nxDeps, dependencyNodeNames, dependencyName);
    }
}
//# sourceMappingURL=project-graph-utils.js.map