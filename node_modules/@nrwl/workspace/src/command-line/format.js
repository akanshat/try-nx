"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path = require("path");
const shared_1 = require("./shared");
const fileutils_1 = require("../utilities/fileutils");
const project_graph_1 = require("../core/project-graph");
const affected_project_graph_1 = require("../core/affected-project-graph");
const file_utils_1 = require("../core/file-utils");
const utils_1 = require("./utils");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const prettier = require("prettier");
const devkit_1 = require("@nrwl/devkit");
const object_sort_1 = require("@nrwl/tao/src/utils/object-sort");
const PRETTIER_PATH = require.resolve('prettier/bin-prettier');
function format(command, args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { nxArgs } = utils_1.splitArgsIntoNxArgsAndOverrides(args, 'affected');
        const workspaceJsonPath = workspace_1.workspaceConfigName(app_root_1.appRootPath);
        const patterns = (yield getPatterns(Object.assign(Object.assign({}, args), nxArgs))).map((p) => `"${p}"`);
        // Chunkify the patterns array to prevent crashing the windows terminal
        const chunkList = chunkify(patterns, 50);
        switch (command) {
            case 'write':
                updateWorkspaceJsonToMatchFormatVersion();
                sortWorkspaceJson();
                sortNxJson();
                sortTsConfig();
                chunkList.push([workspaceJsonPath, 'nx.json', 'tsconfig.base.json']);
                chunkList.forEach((chunk) => write(chunk));
                break;
            case 'check':
                chunkList.forEach((chunk) => check(chunk));
                break;
        }
    });
}
exports.format = format;
function getPatterns(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const supportedExtensions = prettier
            .getSupportInfo()
            .languages.flatMap((language) => language.extensions)
            .filter((extension) => !!extension);
        const matchAllPattern = `**/*{${supportedExtensions.join(',')}}`;
        const allFilesPattern = [matchAllPattern];
        if (args.all) {
            return allFilesPattern;
        }
        try {
            if (args.projects && args.projects.length > 0) {
                return getPatternsFromProjects(args.projects, matchAllPattern);
            }
            const p = shared_1.parseFiles(args);
            const patterns = p.files.filter((f) => fileutils_1.fileExists(f) && supportedExtensions.includes(path.extname(f)));
            return args.libsAndApps
                ? yield getPatternsFromApps(patterns, matchAllPattern)
                : patterns;
        }
        catch (_a) {
            return allFilesPattern;
        }
    });
}
function getPatternsFromApps(affectedFiles, matchAllPattern) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = project_graph_1.onlyWorkspaceProjects(yield project_graph_1.createProjectGraphAsync('4.0'));
        const affectedGraph = affected_project_graph_1.filterAffected(graph, file_utils_1.calculateFileChanges(affectedFiles));
        return getPatternsFromProjects(Object.keys(affectedGraph.nodes), matchAllPattern);
    });
}
function getPatternsFromProjects(projects, matchAllPattern) {
    const roots = shared_1.getProjectRoots(projects);
    return roots.map((root) => `${root}/${matchAllPattern}`);
}
function chunkify(target, size) {
    return target.reduce((current, value, index) => {
        if (index % size === 0)
            current.push([]);
        current[current.length - 1].push(value);
        return current;
    }, []);
}
function write(patterns) {
    if (patterns.length > 0) {
        child_process_1.execSync(`node "${PRETTIER_PATH}" --write ${patterns.join(' ')}`, {
            stdio: [0, 1, 2],
        });
    }
}
function check(patterns) {
    if (patterns.length > 0) {
        try {
            child_process_1.execSync(`node "${PRETTIER_PATH}" --list-different ${patterns.join(' ')}`, {
                stdio: [0, 1, 2],
            });
        }
        catch (_a) {
            process.exit(1);
        }
    }
}
function updateWorkspaceJsonToMatchFormatVersion() {
    const workspaceConfig = workspace_1.workspaceConfigName(app_root_1.appRootPath);
    try {
        const workspaceJson = devkit_1.readJsonFile(workspaceConfig);
        const reformatted = workspace_1.reformattedWorkspaceJsonOrNull(workspaceJson);
        if (reformatted) {
            devkit_1.writeJsonFile(workspaceConfig, reformatted);
        }
    }
    catch (e) {
        console.error(`Failed to format: ${path}`);
        console.error(e);
    }
}
function sortWorkspaceJson() {
    const workspaceJsonPath = workspace_1.workspaceConfigName(app_root_1.appRootPath);
    try {
        const workspaceJson = devkit_1.readJsonFile(workspaceJsonPath);
        if (Object.entries(workspaceJson.projects).length !== 0) {
            const sortedProjects = object_sort_1.sortObjectByKeys(workspaceJson.projects);
            workspaceJson.projects = sortedProjects;
            devkit_1.writeJsonFile(workspaceJsonPath, workspaceJson);
        }
    }
    catch (e) {
        // catch noop
    }
}
function sortNxJson() {
    try {
        const nxJsonPath = path.join(app_root_1.appRootPath, 'nx.json');
        const nxJson = devkit_1.readJsonFile(nxJsonPath);
        const sortedProjects = object_sort_1.sortObjectByKeys(nxJson.projects);
        nxJson.projects = sortedProjects;
        devkit_1.writeJsonFile(nxJsonPath, nxJson);
    }
    catch (e) {
        // catch noop
    }
}
function sortTsConfig() {
    try {
        const tsconfigPath = path.join(app_root_1.appRootPath, 'tsconfig.base.json');
        const tsconfig = devkit_1.readJsonFile(tsconfigPath);
        const sortedPaths = object_sort_1.sortObjectByKeys(tsconfig.compilerOptions.paths);
        tsconfig.compilerOptions.paths = sortedPaths;
        devkit_1.writeJsonFile(tsconfigPath, tsconfig);
    }
    catch (e) {
        // catch noop
    }
}
//# sourceMappingURL=format.js.map