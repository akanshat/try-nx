"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.affected = void 0;
const tslib_1 = require("tslib");
const affected_project_graph_1 = require("../core/affected-project-graph");
const file_utils_1 = require("../core/file-utils");
const project_graph_1 = require("../core/project-graph");
const default_reporter_1 = require("../tasks-runner/default-reporter");
const run_command_1 = require("../tasks-runner/run-command");
const output_1 = require("../utilities/output");
const project_graph_utils_1 = require("../utilities/project-graph-utils");
const dep_graph_1 = require("./dep-graph");
const print_affected_1 = require("./print-affected");
const connect_to_nx_cloud_1 = require("./connect-to-nx-cloud");
const shared_1 = require("./shared");
const utils_1 = require("./utils");
const perf_hooks_1 = require("perf_hooks");
const empty_reporter_1 = require("../tasks-runner/empty-reporter");
function affected(command, parsedArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        perf_hooks_1.performance.mark('command-execution-begins');
        const { nxArgs, overrides } = utils_1.splitArgsIntoNxArgsAndOverrides(parsedArgs, 'affected', {
            printWarnings: command !== 'print-affected' && !parsedArgs.plain,
        });
        yield connect_to_nx_cloud_1.connectToNxCloudUsingScan(nxArgs.scan);
        const projectGraph = yield project_graph_1.createProjectGraphAsync('4.0');
        const projects = projectsToRun(nxArgs, projectGraph);
        const projectsNotExcluded = applyExclude(projects, nxArgs);
        const env = file_utils_1.readEnvironment(nxArgs.target, projectsNotExcluded);
        const filteredProjects = applyOnlyFailed(projectsNotExcluded, nxArgs, env);
        try {
            switch (command) {
                case 'apps':
                    const apps = filteredProjects
                        .filter((p) => p.type === project_graph_1.ProjectType.app)
                        .map((p) => p.name);
                    if (parsedArgs.plain) {
                        console.log(apps.join(' '));
                    }
                    else {
                        if (apps.length) {
                            output_1.output.log({
                                title: 'Affected apps:',
                                bodyLines: apps.map((app) => `${output_1.output.colors.gray('-')} ${app}`),
                            });
                        }
                    }
                    break;
                case 'libs':
                    const libs = filteredProjects
                        .filter((p) => p.type === project_graph_1.ProjectType.lib)
                        .map((p) => p.name);
                    if (parsedArgs.plain) {
                        console.log(libs.join(' '));
                    }
                    else {
                        if (libs.length) {
                            output_1.output.log({
                                title: 'Affected libs:',
                                bodyLines: libs.map((lib) => `${output_1.output.colors.gray('-')} ${lib}`),
                            });
                        }
                    }
                    break;
                case 'dep-graph':
                    const projectNames = filteredProjects.map((p) => p.name);
                    yield dep_graph_1.generateGraph(parsedArgs, projectNames);
                    break;
                case 'print-affected':
                    if (nxArgs.target) {
                        const projectsWithTarget = allProjectsWithTarget(filteredProjects, nxArgs);
                        print_affected_1.printAffected(projectsWithTarget, filteredProjects, projectGraph, env, nxArgs, overrides);
                    }
                    else {
                        print_affected_1.printAffected([], filteredProjects, projectGraph, env, nxArgs, overrides);
                    }
                    break;
                case 'affected': {
                    const projectsWithTarget = allProjectsWithTarget(filteredProjects, nxArgs);
                    run_command_1.runCommand(projectsWithTarget, projectGraph, env, nxArgs, overrides, nxArgs.hideCachedOutput ? new empty_reporter_1.EmptyReporter() : new default_reporter_1.DefaultReporter(), null);
                    break;
                }
            }
        }
        catch (e) {
            printError(e, parsedArgs.verbose);
            process.exit(1);
        }
    });
}
exports.affected = affected;
function projectsToRun(nxArgs, projectGraph) {
    if (nxArgs.all)
        return projectGraph.nodes;
    let affectedGraph = nxArgs.all
        ? projectGraph
        : affected_project_graph_1.filterAffected(projectGraph, file_utils_1.calculateFileChanges(shared_1.parseFiles(nxArgs).files, nxArgs));
    if (nxArgs.withDeps) {
        affectedGraph = project_graph_1.onlyWorkspaceProjects(project_graph_1.withDeps(projectGraph, Object.values(affectedGraph.nodes)));
    }
    return affectedGraph.nodes;
}
function applyExclude(projects, nxArgs) {
    return Object.keys(projects)
        .filter((key) => !(nxArgs.exclude || []).includes(key))
        .reduce((p, key) => {
        p[key] = projects[key];
        return p;
    }, {});
}
function applyOnlyFailed(projectsNotExcluded, nxArgs, env) {
    return Object.values(projectsNotExcluded).filter((n) => !nxArgs.onlyFailed || !env.workspaceResults.getResult(n.name));
}
function allProjectsWithTarget(projects, nxArgs) {
    return projects.filter((p) => project_graph_utils_1.projectHasTarget(p, nxArgs.target));
}
function printError(e, verbose) {
    const bodyLines = [e.message];
    if (verbose && e.stack) {
        bodyLines.push('');
        bodyLines.push(e.stack);
    }
    output_1.output.error({
        title: 'There was a critical error when running your command',
        bodyLines,
    });
}
//# sourceMappingURL=affected.js.map