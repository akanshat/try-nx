"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskOrchestrator = void 0;
const tslib_1 = require("tslib");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const perf_hooks_1 = require("perf_hooks");
const fs_1 = require("fs");
const forked_process_task_runner_1 = require("./forked-process-task-runner");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const output_1 = require("../utilities/output");
const cache_1 = require("./cache");
const tasks_runner_1 = require("./tasks-runner");
const utils_1 = require("./utils");
const tasks_schedule_1 = require("./tasks-schedule");
class TaskOrchestrator {
    // endregion internal state
    constructor(hasher, initiatingProject, projectGraph, taskGraph, options, hideCachedOutput) {
        this.hasher = hasher;
        this.initiatingProject = initiatingProject;
        this.projectGraph = projectGraph;
        this.taskGraph = taskGraph;
        this.options = options;
        this.hideCachedOutput = hideCachedOutput;
        this.cache = new cache_1.Cache(this.options);
        this.workspace = new workspace_1.Workspaces(app_root_1.appRootPath);
        this.forkedProcessTaskRunner = new forked_process_task_runner_1.ForkedProcessTaskRunner(this.options);
        this.tasksSchedule = new tasks_schedule_1.TasksSchedule(this.taskGraph, this.workspace, this.options);
        // region internal state
        this.reverseTaskDeps = utils_1.calculateReverseDeps(this.taskGraph);
        this.timings = {};
        this.completedTasks = {};
        this.startedTasks = new Set();
        this.waitingForTasks = [];
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // initial scheduling
            this.tasksSchedule.scheduleNextTasks();
            perf_hooks_1.performance.mark('task-execution-begins');
            const threads = [];
            // initial seeding of the queue
            const maxParallel = this.options.parallel
                ? this.options.maxParallel || 3
                : 1;
            for (let i = 0; i < maxParallel; ++i) {
                threads.push(this.executeNextBatchOfTasksUsingTaskSchedule());
            }
            yield Promise.all(threads);
            perf_hooks_1.performance.mark('task-execution-ends');
            perf_hooks_1.performance.measure('command-execution', 'task-execution-begins', 'task-execution-ends');
            this.cache.removeOldCacheRecords();
            return this.covertCompletedTasksToOutputFormat();
        });
    }
    executeNextBatchOfTasksUsingTaskSchedule() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // completed all the tasks
            if (!this.tasksSchedule.hasTasks()) {
                return null;
            }
            const doNotSkipCache = this.options.skipNxCache === false ||
                this.options.skipNxCache === undefined;
            const batch = this.tasksSchedule.nextBatch();
            if (batch) {
                yield this.applyFromCacheOrRunBatch(doNotSkipCache, batch);
                return this.executeNextBatchOfTasksUsingTaskSchedule();
            }
            const task = this.tasksSchedule.nextTask();
            if (task) {
                yield this.applyFromCacheOrRunTask(doNotSkipCache, task);
                return this.executeNextBatchOfTasksUsingTaskSchedule();
            }
            // block until some other task completes, then try again
            return new Promise((res) => this.waitingForTasks.push(res)).then(() => this.executeNextBatchOfTasksUsingTaskSchedule());
        });
    }
    // region Applying Cache
    applyCachedResults(tasks) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cacheableTasks = tasks.filter((t) => this.isCacheableTask(t));
            const res = yield Promise.all(cacheableTasks.map((t) => this.applyCachedResult(t)));
            return res
                .filter((r) => r !== null)
                .map((task) => ({ task, status: 'cache' }));
        });
    }
    applyCachedResult(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cachedResult = yield this.cache.get(task);
            if (!cachedResult || cachedResult.code !== 0)
                return null;
            const outputs = utils_1.getOutputs(this.projectGraph.nodes, task);
            const shouldCopyOutputsFromCache = !!outputs.length &&
                (yield this.cache.shouldCopyOutputsFromCache({ task, cachedResult }, outputs));
            if (shouldCopyOutputsFromCache) {
                yield this.cache.copyFilesFromCache(task.hash, cachedResult, outputs);
            }
            if ((!this.initiatingProject ||
                this.initiatingProject === task.target.project) &&
                !this.hideCachedOutput) {
                const args = utils_1.getCommandArgsForTask(task);
                output_1.output.logCommand(`nx ${args.join(' ')}`, shouldCopyOutputsFromCache
                    ? output_1.TaskCacheStatus.RetrievedFromCache
                    : output_1.TaskCacheStatus.MatchedExistingOutput);
                process.stdout.write(cachedResult.terminalOutput);
            }
            return task;
        });
    }
    // endregion Applying Cache
    // region Batch
    applyFromCacheOrRunBatch(doNotSkipCache, batch) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const taskEntries = Object.entries(batch.taskGraph.tasks);
            const tasks = taskEntries.map(([, task]) => task);
            yield this.preRunSteps(tasks);
            let results = doNotSkipCache ? yield this.applyCachedResults(tasks) : [];
            // Run tasks that were not cached
            if (results.length !== taskEntries.length) {
                const unrunTaskGraph = utils_1.removeTasksFromTaskGraph(batch.taskGraph, results.map(({ task }) => task.id));
                // cache prep
                for (const task of Object.values(unrunTaskGraph.tasks)) {
                    const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
                    yield this.cache.removeRecordedOutputsHashes(taskOutputs);
                }
                const batchResults = yield this.runBatch({
                    executorName: batch.executorName,
                    taskGraph: unrunTaskGraph,
                });
                results.push(...batchResults);
            }
            yield this.postRunSteps(results);
            const tasksCompleted = taskEntries.filter(([taskId]) => this.completedTasks[taskId]);
            // Batch is still not done, run it again
            if (tasksCompleted.length !== taskEntries.length) {
                yield this.applyFromCacheOrRunBatch(doNotSkipCache, {
                    executorName: batch.executorName,
                    taskGraph: utils_1.removeTasksFromTaskGraph(batch.taskGraph, tasksCompleted.map(([taskId]) => taskId)),
                });
            }
        });
    }
    runBatch(batch) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const results = yield this.forkedProcessTaskRunner.forkProcessForBatch(batch);
                const batchResultEntries = Object.entries(results);
                // Hash tasks after the batch is done
                // Tasks that are not at the root might need to be updated
                yield Promise.all(batchResultEntries.map(([taskId]) => this.hashTask(this.taskGraph.tasks[taskId])));
                return batchResultEntries.map(([taskId, result]) => ({
                    task: this.taskGraph.tasks[taskId],
                    status: (result.success ? 'success' : 'failure'),
                    terminalOutput: result.terminalOutput,
                }));
            }
            catch (e) {
                return batch.taskGraph.roots.map((rootTaskId) => ({
                    task: this.taskGraph.tasks[rootTaskId],
                    status: 'failure',
                }));
            }
        });
    }
    // endregion Batch
    // region Single Task
    applyFromCacheOrRunTask(doNotSkipCache, task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.preRunSteps([task]);
            // hash the task here
            let results = doNotSkipCache ? yield this.applyCachedResults([task]) : [];
            // the task wasn't cached
            if (results.length === 0) {
                // cache prep
                const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
                yield this.cache.removeRecordedOutputsHashes(taskOutputs);
                const { code, terminalOutput } = yield this.runTaskInForkedProcess(task);
                results.push({
                    task,
                    status: code === 0 ? 'success' : 'failure',
                    terminalOutput,
                });
            }
            yield this.postRunSteps(results);
        });
    }
    runTaskInForkedProcess(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // obtain metadata
                const outputPath = this.cache.temporaryOutputPath(task);
                const forwardOutput = this.shouldForwardOutput(task);
                const pipeOutput = this.pipeOutputCapture(task);
                // execution
                const { code, terminalOutput } = pipeOutput
                    ? yield this.forkedProcessTaskRunner.forkProcessPipeOutputCapture(task, {
                        forwardOutput,
                    })
                    : yield this.forkedProcessTaskRunner.forkProcessDirectOutputCapture(task, {
                        temporaryOutputPath: outputPath,
                        forwardOutput,
                    });
                return {
                    code,
                    terminalOutput,
                };
            }
            catch (e) {
                return {
                    code: 1,
                };
            }
        });
    }
    // endregion Single Task
    // region Lifecycle
    preRunSteps(tasks) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Hash the task before it is run
            yield Promise.all(tasks.map((task) => this.hashTask(task)));
            // timings
            for (const task of tasks) {
                this.storeStartTime(task);
            }
            if ('startTasks' in this.options.lifeCycle) {
                this.options.lifeCycle.startTasks(tasks);
            }
            else {
                for (const task of tasks) {
                    if (!this.startedTasks.has(task.id)) {
                        this.options.lifeCycle.startTask(task);
                        this.startedTasks.add(task.id);
                    }
                }
            }
        });
    }
    storeStartTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`] = {
            start: new Date().getTime(),
            end: undefined,
        };
    }
    postRunSteps(results) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // post-run steps
            for (const { task } of results) {
                this.storeEndTime(task);
            }
            // cache the results
            yield Promise.all(results
                .filter(({ status }) => status !== 'cache' && status !== 'skipped')
                .map((result) => (Object.assign(Object.assign({}, result), { code: result.status === 'cache' || result.status === 'success' ? 0 : 1, outputs: utils_1.getOutputs(this.projectGraph.nodes, result.task) })))
                .filter(({ task, code }) => this.shouldCacheTaskResult(task, code))
                .filter(({ terminalOutput, outputs }) => terminalOutput || outputs)
                .map(({ task, code, terminalOutput, outputs }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield this.cache.put(task, terminalOutput, outputs, code);
                yield this.cache.recordOutputsHash(outputs, task.hash);
                if (terminalOutput) {
                    const outputPath = this.cache.temporaryOutputPath(task);
                    fs_1.writeFileSync(outputPath, terminalOutput);
                }
            })));
            if ('endTasks' in this.options.lifeCycle) {
                this.options.lifeCycle.endTasks(results.map((result) => {
                    const code = result.status === 'success' || result.status === 'cache' ? 0 : 1;
                    return {
                        task: result.task,
                        code,
                    };
                }));
            }
            else {
                for (const { task, status } of results) {
                    const code = status === 'success' || status === 'cache' ? 0 : 1;
                    this.options.lifeCycle.endTask(task, code);
                }
            }
            this.complete(results.map(({ task, status }) => {
                return {
                    taskId: task.id,
                    status,
                };
            }));
            this.tasksSchedule.scheduleNextTasks();
        });
    }
    complete(taskResults) {
        this.tasksSchedule.complete(taskResults.map(({ taskId }) => taskId));
        for (const { taskId, status } of taskResults) {
            if (this.completedTasks[taskId] === undefined) {
                this.completedTasks[taskId] = status;
            }
            if (status === 'failure' || status === 'skipped') {
                this.complete(this.reverseTaskDeps[taskId].map((depTaskId) => ({
                    taskId: depTaskId,
                    status: 'skipped',
                })));
            }
        }
        this.waitingForTasks // release blocked threads
            .forEach((f) => f(null));
        this.waitingForTasks.length = 0;
    }
    storeEndTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`].end =
            new Date().getTime();
    }
    //endregion Lifecycle
    // region utils
    hashTask(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const customHasher = utils_1.getCustomHasher(task, this.workspace);
            const { value, details } = yield (customHasher
                ? customHasher(task, this.taskGraph, this.hasher)
                : this.hasher.hashTaskWithDepsAndContext(task));
            task.hash = value;
            task.hashDetails = details;
        });
    }
    pipeOutputCapture(task) {
        try {
            return (utils_1.getExecutorForTask(task, this.workspace).schema.outputCapture === 'pipe');
        }
        catch (e) {
            return false;
        }
    }
    shouldCacheTaskResult(task, code) {
        return (this.isCacheableTask(task) &&
            (process.env.NX_CACHE_FAILURES == 'true' ? true : code === 0));
    }
    shouldForwardOutput(task) {
        if (!this.isCacheableTask(task))
            return true;
        if (!this.options.parallel)
            return true;
        if (task.target.project === this.initiatingProject)
            return true;
        return false;
    }
    isCacheableTask(task) {
        const cacheable = this.options.cacheableOperations || this.options.cacheableTargets;
        return (cacheable &&
            cacheable.indexOf(task.target.target) > -1 &&
            !this.longRunningTask(task));
    }
    longRunningTask(task) {
        return !!task.overrides['watch'];
    }
    covertCompletedTasksToOutputFormat() {
        return Object.keys(this.completedTasks).map((taskId) => {
            const taskStatus = this.completedTasks[taskId];
            if (taskStatus === 'cache') {
                return {
                    task: this.taskGraph.tasks[taskId],
                    type: tasks_runner_1.AffectedEventType.TaskCacheRead,
                    success: true,
                };
            }
            else if (taskStatus === 'success') {
                return {
                    task: this.taskGraph.tasks[taskId],
                    type: tasks_runner_1.AffectedEventType.TaskComplete,
                    success: true,
                };
            }
            else if (taskStatus === 'failure') {
                return {
                    task: this.taskGraph.tasks[taskId],
                    type: tasks_runner_1.AffectedEventType.TaskComplete,
                    success: false,
                };
            }
            else if (taskStatus === 'skipped') {
                return {
                    task: this.taskGraph.tasks[taskId],
                    type: tasks_runner_1.AffectedEventType.TaskDependencyFailed,
                    success: false,
                };
            }
        });
    }
}
exports.TaskOrchestrator = TaskOrchestrator;
//# sourceMappingURL=task-orchestrator.js.map