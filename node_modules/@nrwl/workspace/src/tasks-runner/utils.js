"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommandArgsForTask = exports.getCliPath = exports.calculateReverseDeps = exports.removeTasksFromTaskGraph = exports.getCustomHasher = exports.getExecutorForTask = exports.getExecutorNameForTask = exports.unparse = exports.getOutputsForTargetAndConfiguration = exports.getOutputs = exports.getDependencyConfigs = exports.getCommand = exports.getCommandAsString = void 0;
const devkit_1 = require("@nrwl/devkit");
const flat_1 = require("flat");
const output_1 = require("../utilities/output");
const build_nodes_1 = require("@nrwl/workspace/src/core/project-graph/build-nodes");
const commonCommands = ['build', 'test', 'lint', 'e2e', 'deploy'];
function getCommandAsString(task) {
    return getCommand(task).join(' ').trim();
}
exports.getCommandAsString = getCommandAsString;
function getCommand(task) {
    const args = Object.entries(task.overrides || {}).map(([prop, value]) => `--${prop}=${value}`);
    const execCommand = devkit_1.getPackageManagerCommand().exec;
    if (commonCommands.includes(task.target.target)) {
        const config = task.target.configuration
            ? [`--configuration`, task.target.configuration]
            : [];
        return [
            execCommand,
            'nx',
            task.target.target,
            task.target.project,
            ...config,
            ...args,
        ];
    }
    else {
        const config = task.target.configuration
            ? `:${task.target.configuration} `
            : '';
        return [
            execCommand,
            'nx',
            'run',
            `${task.target.project}:${task.target.target}${config}`,
            ...args,
        ];
    }
}
exports.getCommand = getCommand;
function getDependencyConfigs({ project, target }, defaultDependencyConfigs, projectGraph) {
    var _a, _b, _c, _d;
    // DependencyConfigs configured in workspace.json override configurations at the root.
    const dependencyConfigs = (_d = (_c = (_b = (_a = projectGraph.nodes[project].data) === null || _a === void 0 ? void 0 : _a.targets[target]) === null || _b === void 0 ? void 0 : _b.dependsOn) !== null && _c !== void 0 ? _c : defaultDependencyConfigs[target]) !== null && _d !== void 0 ? _d : [];
    for (const dependencyConfig of dependencyConfigs) {
        if (dependencyConfig.projects !== 'dependencies' &&
            dependencyConfig.projects !== 'self') {
            output_1.output.error({
                title: `dependsOn is improperly configured for ${project}:${target}`,
                bodyLines: [
                    `dependsOn.projects is ${dependencyConfig.projects} but should be "self" or "dependencies"`,
                ],
            });
            process.exit(1);
        }
    }
    return dependencyConfigs;
}
exports.getDependencyConfigs = getDependencyConfigs;
function getOutputs(p, task) {
    return getOutputsForTargetAndConfiguration(task, p[task.target.project]);
}
exports.getOutputs = getOutputs;
function getOutputsForTargetAndConfiguration(task, node) {
    var _a;
    const { target, configuration } = task.target;
    const targets = node.data.targets[target];
    const options = Object.assign(Object.assign(Object.assign({}, targets.options), (_a = targets === null || targets === void 0 ? void 0 : targets.configurations) === null || _a === void 0 ? void 0 : _a[configuration]), task.overrides);
    if (targets === null || targets === void 0 ? void 0 : targets.outputs) {
        return targets.outputs
            .map((output) => interpolateOutputs(output, options))
            .filter((output) => !!output);
    }
    // Keep backwards compatibility in case `outputs` doesn't exist
    if (options.outputPath) {
        return Array.isArray(options.outputPath)
            ? options.outputPath
            : [options.outputPath];
    }
    else if (target === 'build' || target === 'prepare') {
        return [
            `dist/${node.data.root}`,
            `${node.data.root}/dist`,
            `${node.data.root}/build`,
            `${node.data.root}/public`,
        ];
    }
    else {
        return [];
    }
}
exports.getOutputsForTargetAndConfiguration = getOutputsForTargetAndConfiguration;
function unparse(options) {
    const unparsed = [];
    for (const key of Object.keys(options)) {
        const value = options[key];
        unparseOption(key, value, unparsed);
    }
    return unparsed;
}
exports.unparse = unparse;
function unparseOption(key, value, unparsed) {
    if (value === true) {
        unparsed.push(`--${key}`);
    }
    else if (value === false) {
        unparsed.push(`--no-${key}`);
    }
    else if (Array.isArray(value)) {
        value.forEach((item) => unparseOption(key, item, unparsed));
    }
    else if (Object.prototype.toString.call(value) === '[object Object]') {
        const flattened = flat_1.flatten(value, { safe: true });
        for (const flattenedKey in flattened) {
            unparseOption(`${key}.${flattenedKey}`, flattened[flattenedKey], unparsed);
        }
    }
    else if (typeof value === 'string' &&
        stringShouldBeWrappedIntoQuotes(value)) {
        const sanitized = value.replace(/"/g, String.raw `\"`);
        unparsed.push(`--${key}="${sanitized}"`);
    }
    else if (value != null) {
        unparsed.push(`--${key}=${value}`);
    }
}
function stringShouldBeWrappedIntoQuotes(str) {
    return str.includes(' ') || str.includes('{') || str.includes('"');
}
function interpolateOutputs(template, data) {
    return template.replace(/{([\s\S]+?)}/g, (match) => {
        let value = data;
        let path = match.slice(1, -1).trim().split('.').slice(1);
        for (let idx = 0; idx < path.length; idx++) {
            if (!value[path[idx]]) {
                return;
            }
            value = value[path[idx]];
        }
        return value;
    });
}
function getExecutorNameForTask(task, workspace) {
    const project = workspace.readWorkspaceConfiguration().projects[task.target.project];
    if (!project.targets) {
        project.targets = build_nodes_1.convertNpmScriptsToTargets(project.root);
    }
    if (!project.targets[task.target.target]) {
        throw new Error(`Cannot find configuration for task ${task.target.project}:${task.target.target}`);
    }
    return project.targets[task.target.target].executor;
}
exports.getExecutorNameForTask = getExecutorNameForTask;
function getExecutorForTask(task, workspace) {
    const executor = getExecutorNameForTask(task, workspace);
    const [nodeModule, executorName] = executor.split(':');
    return workspace.readExecutor(nodeModule, executorName);
}
exports.getExecutorForTask = getExecutorForTask;
function getCustomHasher(task, workspace) {
    try {
        const factory = getExecutorForTask(task, workspace).hasherFactory;
        return factory ? factory() : null;
    }
    catch (e) {
        console.error(e);
        throw new Error(`Unable to load hasher for task "${task.id}"`);
    }
}
exports.getCustomHasher = getCustomHasher;
function removeTasksFromTaskGraph(graph, ids) {
    const tasks = {};
    const dependencies = {};
    const removedSet = new Set(ids);
    for (let taskId of Object.keys(graph.tasks)) {
        if (!removedSet.has(taskId)) {
            tasks[taskId] = graph.tasks[taskId];
            dependencies[taskId] = graph.dependencies[taskId].filter((depTaskId) => !removedSet.has(depTaskId));
        }
    }
    return {
        tasks,
        dependencies: dependencies,
        roots: Object.keys(dependencies).filter((k) => dependencies[k].length === 0),
    };
}
exports.removeTasksFromTaskGraph = removeTasksFromTaskGraph;
function calculateReverseDeps(taskGraph) {
    const reverseTaskDeps = {};
    Object.keys(taskGraph.tasks).forEach((t) => {
        reverseTaskDeps[t] = [];
    });
    Object.keys(taskGraph.dependencies).forEach((taskId) => {
        taskGraph.dependencies[taskId].forEach((d) => {
            reverseTaskDeps[d].push(taskId);
        });
    });
    return reverseTaskDeps;
}
exports.calculateReverseDeps = calculateReverseDeps;
function getCliPath(workspaceRoot) {
    const cli = require.resolve(`@nrwl/cli/lib/run-cli.js`, {
        paths: [workspaceRoot],
    });
    return `${cli}`;
}
exports.getCliPath = getCliPath;
function getCommandArgsForTask(task) {
    const args = unparse(task.overrides || {});
    const config = task.target.configuration
        ? `:${task.target.configuration}`
        : '';
    return [
        'run',
        `${task.target.project}:${task.target.target}${config}`,
        ...args,
    ];
}
exports.getCommandArgsForTask = getCommandArgsForTask;
//# sourceMappingURL=utils.js.map