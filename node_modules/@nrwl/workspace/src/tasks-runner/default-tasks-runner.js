"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultTasksRunner = void 0;
const tslib_1 = require("tslib");
const Observable_1 = require("rxjs/internal/Observable");
const task_orchestrator_1 = require("./task-orchestrator");
const perf_hooks_1 = require("perf_hooks");
const task_graph_creator_1 = require("./task-graph-creator");
const hasher_1 = require("../core/hasher/hasher");
class NoopLifeCycle {
    scheduleTask(task) { }
    startTask(task) { }
    endTask(task, code) { }
    startTasks(task) { }
    endTasks(taskResults) { }
}
const defaultTasksRunner = (tasks, options, context) => {
    if (!options.lifeCycle) {
        options.lifeCycle = new NoopLifeCycle();
    }
    return new Observable_1.Observable((subscriber) => {
        runAllTasks(tasks, options, context)
            .then((data) => data.forEach((d) => subscriber.next(d)))
            .catch((e) => {
            console.error('Unexpected error:');
            console.error(e);
            process.exit(1);
        })
            .finally(() => {
            subscriber.complete();
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
        });
    });
};
exports.defaultTasksRunner = defaultTasksRunner;
function printTaskExecution(orchestrator) {
    if (process.env.NX_PERF_LOGGING) {
        console.log('Task Execution Timings:');
        const timings = {};
        Object.keys(orchestrator.timings).forEach((p) => {
            const t = orchestrator.timings[p];
            timings[p] = t.end ? t.end - t.start : null;
        });
        console.log(JSON.stringify(timings, null, 2));
    }
}
function runAllTasks(tasks, options, context) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const defaultTargetDependencies = (_a = context.nxJson.targetDependencies) !== null && _a !== void 0 ? _a : {};
        const taskGraphCreator = new task_graph_creator_1.TaskGraphCreator(context.projectGraph, defaultTargetDependencies);
        const taskGraph = taskGraphCreator.createTaskGraph(tasks);
        perf_hooks_1.performance.mark('task-graph-created');
        perf_hooks_1.performance.measure('nx-prep-work', 'init-local', 'task-graph-created');
        perf_hooks_1.performance.measure('graph-creation', 'command-execution-begins', 'task-graph-created');
        const hasher = new hasher_1.Hasher(context.projectGraph, context.nxJson, options);
        const orchestrator = new task_orchestrator_1.TaskOrchestrator(hasher, context.initiatingProject, context.projectGraph, taskGraph, options, context.hideCachedOutput);
        const res = yield orchestrator.run();
        printTaskExecution(orchestrator);
        return res;
    });
}
exports.default = exports.defaultTasksRunner;
//# sourceMappingURL=default-tasks-runner.js.map