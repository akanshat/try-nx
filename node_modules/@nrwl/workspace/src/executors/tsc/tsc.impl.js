"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tscExecutor = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const project_graph_1 = require("../../core/project-graph");
const assets_1 = require("../../utilities/assets");
const buildable_libs_utils_1 = require("../../utilities/buildable-libs-utils");
const fileutils_1 = require("../../utilities/fileutils");
const compilation_1 = require("../../utilities/typescript/compilation");
function tscExecutor(options, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = normalizeOptions(options, context);
        // const projectRoot = context.workspace.projects[context.projectName].root;
        const projectGraph = project_graph_1.readCachedProjectGraph('4.0');
        const { target, dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projectGraph, context.root, context.projectName, context.targetName, context.configurationName);
        const projectRoot = target.data.root;
        if (dependencies.length > 0) {
            const areDependentProjectsBuilt = buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies);
            if (!areDependentProjectsBuilt) {
                return { success: false };
            }
            normalizedOptions.tsConfig = buildable_libs_utils_1.createTmpTsConfig(path_1.join(context.root, options.tsConfig), context.root, projectRoot, dependencies);
        }
        // this has to happen first so the folder is created where the assets are copied into
        const result = compilation_1.compileTypeScript({
            outputPath: normalizedOptions.outputPath,
            projectName: context.projectName,
            projectRoot,
            tsConfig: normalizedOptions.tsConfig,
        });
        yield assets_1.copyAssets(normalizedOptions.assets, context.root, normalizedOptions.outputPath);
        updatePackageJson(normalizedOptions, projectRoot);
        return result;
    });
}
exports.tscExecutor = tscExecutor;
function getMainFileDirRelativeToProjectRoot(main, projectRoot) {
    const mainFileDir = path_1.dirname(main);
    const relativeDir = devkit_1.normalizePath(path_1.relative(projectRoot, mainFileDir));
    const relativeMainFile = relativeDir === '' ? `./` : `./${relativeDir}/`;
    return relativeMainFile;
}
function normalizeOptions(options, context) {
    return Object.assign(Object.assign({}, options), { outputPath: path_1.join(context.root, options.outputPath), tsConfig: path_1.join(context.root, options.tsConfig) });
}
function updatePackageJson(options, projectRoot) {
    var _a, _b;
    const packageJson = fileutils_1.readJsonFile(path_1.join(projectRoot, 'package.json'));
    if (packageJson.main && packageJson.typings) {
        return;
    }
    const mainFile = path_1.basename(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = getMainFileDirRelativeToProjectRoot(options.main, projectRoot);
    const mainJsFile = `${relativeMainFileDir}${mainFile}.js`;
    const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
    packageJson.main = (_a = packageJson.main) !== null && _a !== void 0 ? _a : mainJsFile;
    packageJson.typings = (_b = packageJson.typings) !== null && _b !== void 0 ? _b : typingsFile;
    const outputPackageJson = path_1.join(options.outputPath, 'package.json');
    fileutils_1.writeJsonFile(outputPackageJson, packageJson);
}
exports.default = tscExecutor;
//# sourceMappingURL=tsc.impl.js.map