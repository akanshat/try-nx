"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RULE_NAME = void 0;
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const runtime_lint_utils_1 = require("@nrwl/workspace/src/utils/runtime-lint-utils");
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const create_eslint_rule_1 = require("../utils/create-eslint-rule");
const devkit_1 = require("@nrwl/devkit");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const file_utils_1 = require("@nrwl/workspace/src/core/file-utils");
const target_project_locator_1 = require("@nrwl/workspace/src/core/target-project-locator");
const graph_utils_1 = require("@nrwl/workspace/src/utils/graph-utils");
const fileutils_1 = require("@nrwl/workspace/src/utilities/fileutils");
exports.RULE_NAME = 'enforce-module-boundaries';
exports.default = create_eslint_rule_1.createESLintRule({
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: `Ensure that module boundaries are respected within the monorepo`,
            category: 'Best Practices',
            recommended: 'error',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    enforceBuildableLibDependency: { type: 'boolean' },
                    allowCircularSelfDependency: { type: 'boolean' },
                    allow: [{ type: 'string' }],
                    depConstraints: [
                        {
                            type: 'object',
                            properties: {
                                sourceTag: { type: 'string' },
                                onlyDependOnLibsWithTags: [{ type: 'string' }],
                            },
                            additionalProperties: false,
                        },
                    ],
                },
                additionalProperties: false,
            },
        ],
        messages: {
            noRelativeOrAbsoluteImportsAcrossLibraries: `Libraries cannot be imported by a relative or absolute path, and must begin with a npm scope`,
            noCircularDependencies: `Circular dependency between "{{sourceProjectName}}" and "{{targetProjectName}}" detected: {{path}}\n\nCircular file chain:\n{{filePaths}}`,
            noSelfCircularDependencies: `Projects should use relative imports to import from other files within the same project. Use "./path/to/file" instead of import from "{{imp}}"`,
            noImportsOfApps: 'Imports of apps are forbidden',
            noImportsOfE2e: 'Imports of e2e projects are forbidden',
            noImportOfNonBuildableLibraries: 'Buildable libraries cannot import or export from non-buildable libraries',
            noImportsOfLazyLoadedLibraries: `Imports of lazy-loaded libraries are forbidden`,
            projectWithoutTagsCannotHaveDependencies: `A project without tags matching at least one constraint cannot depend on any libraries`,
            tagConstraintViolation: `A project tagged with "{{sourceTag}}" can only depend on libs tagged with {{allowedTags}}`,
        },
    },
    defaultOptions: [
        {
            allow: [],
            depConstraints: [],
            enforceBuildableLibDependency: false,
            allowCircularSelfDependency: false,
        },
    ],
    create(context, [{ allow, depConstraints, enforceBuildableLibDependency, allowCircularSelfDependency, },]) {
        /**
         * Globally cached info about workspace
         */
        const projectPath = devkit_1.normalizePath(global.projectPath || app_root_1.appRootPath);
        if (!global.projectGraph) {
            const nxJson = file_utils_1.readNxJson();
            global.npmScope = nxJson.npmScope;
            /**
             * Because there are a number of ways in which the rule can be invoked (executor vs ESLint CLI vs IDE Plugin),
             * the ProjectGraph may or may not exist by the time the lint rule is invoked for the first time.
             */
            try {
                global.projectGraph = runtime_lint_utils_1.mapProjectGraphFiles(project_graph_1.readCachedProjectGraph('4.0'));
            }
            catch (_a) { }
        }
        if (!global.projectGraph) {
            return {};
        }
        const npmScope = global.npmScope;
        const projectGraph = global.projectGraph;
        if (!global.targetProjectLocator) {
            global.targetProjectLocator = new target_project_locator_1.TargetProjectLocator(projectGraph.nodes);
        }
        const targetProjectLocator = global
            .targetProjectLocator;
        function run(node) {
            // Ignoring ExportNamedDeclarations like:
            // export class Foo {}
            if (!node.source) {
                return;
            }
            // accept only literals because template literals have no value
            if (node.source.type !== experimental_utils_1.AST_NODE_TYPES.Literal) {
                return;
            }
            const imp = node.source.value;
            // whitelisted import
            if (allow.some((a) => runtime_lint_utils_1.matchImportWithWildcard(a, imp))) {
                return;
            }
            const sourceFilePath = runtime_lint_utils_1.getSourceFilePath(context.getFilename(), projectPath);
            // check for relative and absolute imports
            const sourceProject = runtime_lint_utils_1.findSourceProject(projectGraph, sourceFilePath);
            if (runtime_lint_utils_1.isRelativeImportIntoAnotherProject(imp, projectPath, projectGraph, sourceFilePath, sourceProject) ||
                runtime_lint_utils_1.isAbsoluteImportIntoAnotherProject(imp)) {
                context.report({
                    node,
                    messageId: 'noRelativeOrAbsoluteImportsAcrossLibraries',
                    data: {
                        npmScope,
                    },
                });
                return;
            }
            const targetProject = runtime_lint_utils_1.findProjectUsingImport(projectGraph, targetProjectLocator, sourceFilePath, imp, npmScope);
            // If source or target are not part of an nx workspace, return.
            if (!sourceProject || !targetProject) {
                return;
            }
            // same project => allow
            if (sourceProject === targetProject) {
                // we only allow relative paths within the same project
                if (!allowCircularSelfDependency && !fileutils_1.isRelativePath(imp)) {
                    context.report({
                        node,
                        messageId: 'noSelfCircularDependencies',
                        data: {
                            imp,
                        },
                    });
                }
                return;
            }
            // project => npm package
            if (project_graph_1.isNpmProject(targetProject)) {
                return;
            }
            // check constraints between libs and apps
            // check for circular dependency
            const circularPath = graph_utils_1.checkCircularPath(global.projectGraph, sourceProject, targetProject);
            if (circularPath.length !== 0) {
                const circularFilePath = graph_utils_1.findFilesInCircularPath(circularPath);
                context.report({
                    node,
                    messageId: 'noCircularDependencies',
                    data: {
                        sourceProjectName: sourceProject.name,
                        targetProjectName: targetProject.name,
                        path: circularPath.reduce((acc, v) => `${acc} -> ${v.name}`, sourceProject.name),
                        filePaths: circularFilePath
                            .map((files) => files.length > 1 ? `[${files.join(',')}]` : files[0])
                            .reduce((acc, files) => `${acc}\n- ${files}`, `- ${sourceFilePath}`),
                    },
                });
                return;
            }
            // cannot import apps
            if (targetProject.type === project_graph_1.ProjectType.app) {
                context.report({
                    node,
                    messageId: 'noImportsOfApps',
                });
                return;
            }
            // cannot import e2e projects
            if (targetProject.type === project_graph_1.ProjectType.e2e) {
                context.report({
                    node,
                    messageId: 'noImportsOfE2e',
                });
                return;
            }
            // buildable-lib is not allowed to import non-buildable-lib
            if (enforceBuildableLibDependency === true &&
                sourceProject.type === project_graph_1.ProjectType.lib &&
                targetProject.type === project_graph_1.ProjectType.lib) {
                if (runtime_lint_utils_1.hasBuildExecutor(sourceProject) &&
                    !runtime_lint_utils_1.hasBuildExecutor(targetProject)) {
                    context.report({
                        node,
                        messageId: 'noImportOfNonBuildableLibraries',
                    });
                    return;
                }
            }
            // if we import a library using loadChildren, we should not import it using es6imports
            if (node.type === experimental_utils_1.AST_NODE_TYPES.ImportDeclaration &&
                node.importKind !== 'type' &&
                runtime_lint_utils_1.onlyLoadChildren(projectGraph, sourceProject.name, targetProject.name, [])) {
                context.report({
                    node,
                    messageId: 'noImportsOfLazyLoadedLibraries',
                });
                return;
            }
            // check that dependency constraints are satisfied
            if (depConstraints.length > 0) {
                const constraints = runtime_lint_utils_1.findConstraintsFor(depConstraints, sourceProject);
                // when no constrains found => error. Force the user to provision them.
                if (constraints.length === 0) {
                    context.report({
                        node,
                        messageId: 'projectWithoutTagsCannotHaveDependencies',
                    });
                    return;
                }
                for (let constraint of constraints) {
                    if (runtime_lint_utils_1.hasNoneOfTheseTags(targetProject, constraint.onlyDependOnLibsWithTags || [])) {
                        const allowedTags = constraint.onlyDependOnLibsWithTags
                            .map((s) => `"${s}"`)
                            .join(', ');
                        context.report({
                            node,
                            messageId: 'tagConstraintViolation',
                            data: {
                                sourceTag: constraint.sourceTag,
                                allowedTags,
                            },
                        });
                        return;
                    }
                }
            }
        }
        return {
            ImportDeclaration(node) {
                run(node);
            },
            ImportExpression(node) {
                run(node);
            },
            ExportAllDeclaration(node) {
                run(node);
            },
            ExportNamedDeclaration(node) {
                run(node);
            },
        };
    },
});
//# sourceMappingURL=enforce-module-boundaries.js.map